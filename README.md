# Experimental Robotics Lab Assignment 2:
## I. Cluedo investigation

![Cluedo_Map](https://user-images.githubusercontent.com/48509825/161590960-7892a0c4-97c4-4b8c-9630-f4886926a472.jpg)

Figure 1: Cluedo map of the original game

## II. Description:
In this repository you can find a solution of a Cluedo like investigation game played by Sherlock robot.
Sherlock has to collect hints moving in the environment in a completely autonomous way.
An hypothesis has the following structure: [ID, killer, killer_place, killer_weapon].
Killer is the name of the murder, killer_place is the name of the room in wich took place the murder
and finally killer_weapon is the name of the weapon used to complete the murder.
An hypothesis is complete if all the fields are filled, it is consistent if it is complete and only one name for each field is present.
In figure 2 and 3 you can see the simulation enviroment of Rviz and Gazebo respectively.
IN the simulation are present 4 markers, in position [-3,0], [3,0], [0,3], [0,-3] to a random high of 0.75 or 1.25, (Figure 2).
Once a marker is reached with Sherlock's arm a new hint is generated, notice that sometimes a malformed hint could be generated.


![Rviz](https://user-images.githubusercontent.com/48509825/161597045-612042ba-51df-43fa-bba0-c3e3dda0dcaf.jpeg)
Figure 2: Sherlock in Rviz simulator


![Gazebo](https://user-images.githubusercontent.com/48509825/161597048-1cdd427d-e2b3-4cc7-af49-7e92d99416c0.jpeg)
Figure 3: Sherlock in Gazebo simulator

Once an hypothesis is consistent Sherlock has to go in the centre of the arena in order to ask to the oracle if the collected hypothesis
is the true one. If the hypothesis is wrong Sherlock has to collect other hints until the true hypothesis is found.
The game ends when the oracle validates Sherlock solution.
The peculiarity of this assignment is that the behaviour above descripted is no more managed as in the previous assignment trough a 
FSM but in this case trough ROSPlan.

## III. ROSPlan:
The ROSPlan framework provides a generic method for task planning in a ROS system. ROSPlan encapsulates both planning and dispatch. 
It provides with a simple interface, and already includes interfaces to common ROS libraries.
In order to use ROSPlan is necessary to make a problem.pddl in wich all the objects, predicates and action are described and also a 
problem to be solved.
Once the domain is instanciated, ROSPlan autonomously is able to solve the problem and then dispatch the plan, executing one by one the
actions of the plan.
You can see in Figure 4 the general ROSPlan Overview

![image](https://user-images.githubusercontent.com/48509825/161599654-313dc303-b913-4068-922e-8d9c7c57f520.png)

Figure 4: ROSPlan Overview

## IV. SW Architecture:
The assignment is composed by three main packages:

* **sherlock_moveit**: is the pkg generated by moveit_setup_assistant starting from sherlock.xacro in the erl2/urdf.
* **erl2**: contains the urdf of the robot (xacro file, materials and gazebo plugins), the Gazebo scene, all the custom services, action, nodes
            and PDDL files (domain and problem) implemented to reach the wanted behaviour described in section II and also doxygen documentation.
* **my_rosplan_interface**: contains all the actions described into the PDDL domain file.


![Architecture_Ass2](https://user-images.githubusercontent.com/48509825/163277351-75794328-0004-4fe7-9f19-1a512d52ffd4.png)

## V. All you need:
### Services
* go_to_point.py is the node demanded to move Sherlock from a wp to the next. This node is implemented as an action.
            It is a FSM in wich the first state adjust the orientation with respect to the target. The second phase publish a linear velocity
            until the target is reached. Once the target is reached the third and final state adjust the final orientation of the robot.
* move_arm.py is the node demanded to move Sherlock arm. Thanks to MoveIt! this node simply take the requested joints' configuration and then 
            planning the trajectory (in joint space) thanks to Sherlock MoveIt! pkg ad hoc developed.
* update_knowledge_replan.py this node is demanded to initialize ROSPlan generating all the clients (problem_interface, planner interface
            parsing interface and plan_dispatcher). Although this node has the scope of replanning until the solution is found.
* replan.py this node is demanded to cancel the current plan and to force a replan
* perceive_test_consistency.py this node perceive the hints generated by the oracle while the e.e is into a Marker.
            Altough (since aRMoR is not implemented for building reasons) this node provide a service for test the consistency of the hypothesis.
            
### Action Interfaces
* initialize.cpp initialize the plan. In particular it extends Sherlock's arm  and moves it into the first waypoint.
* go_to_waypoint.cpp call the service for moving Sherlock from a wp to another
* take_hint.cpp once arrived in a wp it call the service for moving the arm. Completed the acquisition of the hint it extends the arm
* check_hypothesis.cpp call the service in order to check if at least one hypothesis is consistent, if no force replan.
* test_hypothesis.cpp if at least one hypothesis is consistent, move the robot in the centre of the arena in order to tell the solution to the oracle.
            If the solution is wrong, force replan otherwise the game is finished
            
### Oracle
The Oracle (already implemented), once the e.e is into a Marker, provide a hint randomly. Hints can be malformed or incompleted or repetitive.
The Oracle knows also the final solution ID, that Sherlock has to collect during the game

###
          
        
