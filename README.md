# Experimental Robotics Lab Assignment 2:
## I. Cluedo investigation

![Cluedo_Map](https://user-images.githubusercontent.com/48509825/161590960-7892a0c4-97c4-4b8c-9630-f4886926a472.jpg)

Figure 1: Cluedo map of the original game

## II. Description
In this repository you can find a solution of a Cluedo like investigation game played by Sherlock robot.
Sherlock has to collect hints moving in the environment in a completely autonomous way.
An hypothesis has the following structure: [ID, killer, killer_place, killer_weapon].
Killer is the name of the murder, killer_place is the name of the room in wich took place the murder
and finally killer_weapon is the name of the weapon used to complete the murder.
An hypothesis is complete if all the fields are filled, it is consistent if it is complete and only one name for each field is present.
In figure 2 and 3 you can see the simulation enviroment of Rviz and Gazebo respectively.
IN the simulation are present 4 markers, in position [-3,0], [3,0], [0,3], [0,-3] to a random high of 0.75 or 1.25, (Figure 2).
Once a marker is reached with Sherlock's arm a new hint is generated, notice that sometimes a malformed hint could be generated.


![Rviz](https://user-images.githubusercontent.com/48509825/161597045-612042ba-51df-43fa-bba0-c3e3dda0dcaf.jpeg)
Figure 2: Sherlock in Rviz simulator


![Gazebo](https://user-images.githubusercontent.com/48509825/161597048-1cdd427d-e2b3-4cc7-af49-7e92d99416c0.jpeg)
Figure 3: Sherlock in Gazebo simulator

Once an hypothesis is consistent Sherlock has to go in the centre of the arena in order to ask to the oracle if the collected hypothesis
is the true one. If the hypothesis is wrong Sherlock has to collect other hints until the true hypothesis is found.
The game ends when the oracle validates Sherlock solution.
The peculiarity of this assignment is that the behaviour above descripted is no more managed as in the previous assignment trough a 
FSM but in this case trough ROSPlan.

## III. ROSPlan
The ROSPlan framework provides a generic method for task planning in a ROS system. ROSPlan encapsulates both planning and dispatch. 
It provides with a simple interface, and already includes interfaces to common ROS libraries.
In order to use ROSPlan is necessary to make a problem.pddl in wich all the objects, predicates and action are described and also a 
problem to be solved.
Once the domain is instanciated, ROSPlan autonomously is able to solve the problem and then dispatch the plan, executing one by one the
actions of the plan.
You can see in Figure 4 the general ROSPlan Overview

![image](https://user-images.githubusercontent.com/48509825/161599654-313dc303-b913-4068-922e-8d9c7c57f520.png)

Figure 4: ROSPlan Overview

## IV. SW Architecture
The assignment is composed by three main packages:

* **sherlock_moveit**: is the pkg generated by moveit_setup_assistant starting from sherlock.xacro in the erl2/urdf.
* **erl2**: contains the urdf of the robot (xacro file, materials and gazebo plugins), the Gazebo scene, all the custom services, action, nodes
            and PDDL files (domain and problem) implemented to reach the wanted behaviour described in section II and also doxygen documentation.
* **my_rosplan_interface**: contains all the actions described into the PDDL domain file.


![Architecture_Ass2](https://user-images.githubusercontent.com/48509825/163277351-75794328-0004-4fe7-9f19-1a512d52ffd4.png)

## V. All you need
### Services
* **go_to_point.py** is the node demanded to move Sherlock from a wp to the next. This node is implemented as an action.
            It is a FSM in wich the first state adjust the orientation with respect to the target. The second phase publish a linear velocity
            until the target is reached. Once the target is reached the third and final state adjust the final orientation of the robot.
* **move_arm.py** is the node demanded to move Sherlock arm. Thanks to MoveIt! this node simply take the joints configuration wanted and then 
            planning the trajectory (in joint space-FK) thanks to Sherlock MoveIt! pkg ad hoc developed.
* **update_knowledge_replan.py** this node is demanded to initialize ROSPlan generating all the clients (problem_interface, planner interface
            parsing interface and plan_dispatcher). Although this node has the scope of replanning until the solution is found.
* **replan.py** this node is demanded to cancel the current plan and to force a replan
* **perceive_test_consistency.py** this node perceive the hints generated by the oracle while the e.e is into a Marker.
            Altough (since aRMoR is not implemented for building reasons) this node provide a service for test the consistency of the hypothesis.
* **final_oracle** The Oracle node (already implemented), once Sherlock e.e is into a Marker, provides an hint randomly. Hints can be malformed or incompleted or repetitive. The Oracle knows also the final solution ID, that Sherlock has to collect during the game
            
  
You can find all the elencated services into the **erl2** pkg into the **scripts** folder.
            
### Action Interfaces
* **initialize.cpp** initialize the plan. In particular it extends Sherlock's arm  and moves it into the first waypoint.
* **go_to_waypoint.cpp** call the service for moving Sherlock from a wp to another and maps each waypoint with its location and orientation.
* **take_hint.cpp** once arrived in a wp it set each joints position and call the service for moving the arm. 
            Completed the acquisition of the hint it extends the arm calling again the move_arm service.
* **check_hypothesis.cpp** call update_knowledge_replan service in order to check if at least one hypothesis is consistent,if yes test_hypothesis will be executed,  if no force replan calling replan service.
* **test_hypothesis.cpp** if at least one hypothesis is consistent, it moves the robot in the centre of the arena in order to tell the solution to the oracle.
            If the solution is wrong it forces replan otherwise the game is finished.
            
 All the elencated actions are into **my_rosplan_interface** pkg into **src** folder.
            
### PDDL Domain
All the listed actions above are durative-actions of PDDL Domain file: **domain.pddl** into the **erl2** pkg into **common** folder.
The problem file **problem.pddl** into **erl2** pkg into **common** folder, specifies the four waypoints, and declare that the current plan is not initialized.
For each plan the goal will be to say an hypothesis to the oracle, of course this action will be executed only if at least one hypothesis is completed and consistent.

### Launch Files
* **sherlock_moveit/launch/demo_gazebo.launch** is demanded to execute all the moveit plugins and controllers for the arm and spawns Sherlock into the predefined Gazebo scene. It also executes the **assignment.launch** file already developed to spawn Rviz with the markers and execute the **simulation.cpp** file already developed to source the Oracle node.
* **erl2/launch/services.launch** is demanded to execute the three services: go_to_point.py, move_arm.py and perceive_test_consistency.py needed for the simulation.
* **erl2/launch/rosplan.launch** is demanded to source the domain and problem pddl files into ROSPlan and to execute all ROSPlan components.
                                 It also specifies for each pddl durative action its corresponding action interface.
* **launch_all_investigation** executable that launch the two above launch files with a bit of deelay
                              
### Oracle
The Oracle (already implemented), once the e.e is into a Marker, provide a hint randomly. Hints can be malformed or incompleted or repetitive.
The Oracle knows also the final solution ID, that Sherlock has to collect during the game

### Documentation
It is also present Doxygen documentation for erl2 and my_action_interface. docs/html/**index.html**

### Sequence Diagram



![Sequence_Diagram](https://user-images.githubusercontent.com/48509825/163598843-555b7446-d650-433a-9538-1edb64e50c86.png)


### Video
In the repo you can find the demonstrative accelerated video (**SpeedAssignment2Video.mp4**) of the simulation.
If you don't want to download the video, [ClickHere!](https://unigeit-my.sharepoint.com/:v:/g/personal/s4506472_studenti_unige_it/Ec63UMzhJmJCvZkIPSoI1E4BGB4N7ezUqN91WxHEu1nJKA?e=vKV7zm) to see it online.



## VI. How to run the simulation
* If you are not familiar with ROSPlan, I suggest you to see its GitHub page and download it --> [ROSPlan](https://github.com/KCL-Planning/ROSPlan).
* You have to clone this repository into your ros workspace:
```
git clone https://github.com/ermannoGirardo/exproblab_assignment2
```
* You have to compile and build the workspace
```
catkin_make -DCATKIN_WHITELIST_PACKAGES=""
```
* If you want to execute one by one the launch files:
```
roslaunch sherlock_moveit demo_gazebo.launch
```
```
roslaunch erl2 services.launch
```
```
roslaunch erl2 rosplan.lauch
```
!!! Launch the files in this specific sequence!!! If you don't want to see all the warning messages you can add **2</dev/null** after each command.

* If you want there is also a bash file that execute all for you.
So, first you have to install gnome terminal, if you haven't yet:
  ```
  apt install gnome-terminal
  ```
  Then you have to modify the permit of the file, in order to make it an executable file:
  ```
  roscd erl2
  ```
  ```
  chmode +x launch_all_investigation.sh
  ```
  And now you can execute the file:
  ```
  ./launch_all_investigation
  ```
  
## VII System Features
  * Simulation planned by ROSPlan thanks to pddl domain and problem file.
  * Replanner ready to make a new plan when the current plan is no more solvable
  * Manipulation thanks to a custom URDF with five DoF arm
  * Test hypotheses only when it is completed and consistent
  
  
  
## VIII System Limitations and Possible Improvements
  The investigation is very long. It is possible to reduce investigation time in the following ways:
  I. avoiding that the oracle generates malformed hints
  II. avoiding that the oracle repeats the hints
  III. once an hypothesis is not consistent is useless to acquire hints about that hypothesis
  In order to fix these limitations it is possible to:
  I. Modify the Oracle introducing an if statement, if the hint is malformed ask another hint until it is not malformed.
  II. Store all the hints that the Oracle has given until now and check that the next hint it is not already given
  III. Add an if statement in order to avoid that the Oracle generates a new hint for an inconsistent hypothesis
  
  Sometimes MoveIt fails to move the arm. This is not a problem in this particular scenario, but is possible to fix this problem implementing a recovery action that 
  before executing the go_to_point action check the position of the gripper.
  
  ROSPlan visits always waypoints in the same order. In order to fix this limitation is possible, before replanning, store the last waypoint into the PDDL
  problem file.
  

## IX About the Author
**Robotics Engineer** @UniversitÃ  degli Studi di Genova via Opera Pia. 
**Phone number:** 3451552733
**Email:** girardoermanno@gmail.com
**GitHub Page:** [Click Here](https://github.com/ermannoGirardo)
**Assignment 3:** [Click Here](https://github.com/ermannoGirardo/exproblab_assignment3)
